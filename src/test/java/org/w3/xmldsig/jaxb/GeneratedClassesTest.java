package org.w3.xmldsig.jaxb;

import java.lang.reflect.Method;
import java.math.BigInteger;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

/**
 * Unit tests for all the ODM reader classes that are automatically generated by the JAXB xjc tool.
 *
 * @author <a href="mailto:f.debruijn@vumc.nl">Freek de Bruijn</a>
 */
public class GeneratedClassesTest {
    /**
     * Test whether all fields can be set and get.
     */
    @Test
    public void testFields() {
        testFieldsForClasses(CanonicalizationMethodType.class, DigestMethodType.class, DSAKeyValueType.class,
                             KeyInfoType.class, KeyValueType.class, ObjectType.class, PGPDataType.class,
                             ManifestType.class, ReferenceType.class, RetrievalMethodType.class, RSAKeyValueType.class,
                             SignatureMethodType.class, SignaturePropertiesType.class, SignaturePropertyType.class,
                             SignatureType.class, SignatureValueType.class, SignedInfoType.class, SPKIDataType.class,
                             TransformsType.class, TransformType.class, X509DataType.class, X509IssuerSerialType.class);
    }

    /**
     * Test whether all fields can be set and get for objects of a range of classes.
     *
     * @param dataTypeClasses all the data type classes to test.
     */
    private void testFieldsForClasses(final Class... dataTypeClasses) {
        for (final Class dataTypeClass : dataTypeClasses)
            testFieldsForClass(dataTypeClass);
    }

    /**
     * Test whether all fields can be set and get for objects of a specific class.
     *
     * @param dataTypeClass the data type class to test.
     */
    private void testFieldsForClass(final Class dataTypeClass) {
        for (final Method method : dataTypeClass.getDeclaredMethods())
            if (method.getName().startsWith("get")) {
                final String propertyName = method.getName().substring(3);
                if (method.getReturnType() != List.class)
                    testSingleField(dataTypeClass, propertyName);
                else
                    testListField(dataTypeClass, propertyName);
            }
    }

    /**
     * Test whether a single field of a specific data type class can be set and get.
     *
     * @param dataTypeClass the data type class to test.
     * @param propertyName  the name of the property (starting with one or more upper case characters).
     */
    private void testSingleField(final Class dataTypeClass, final String propertyName) {
        try {
            final String fieldName = getFieldName(propertyName);
            final Class propertyClass = createDataType(dataTypeClass).getClass().getDeclaredField(fieldName).getType();

            final Object propertyValue;
            if (propertyClass == String.class)
                propertyValue = "value";
            else if (propertyClass == byte[].class)
                propertyValue = "value".getBytes();
            else if (propertyClass == BigInteger.class)
                propertyValue = new BigInteger("123456");
            else
                propertyValue = createDataType(propertyClass);

            final Object dataType = createDataType(dataTypeClass);
            final Method setValueMethod = dataType.getClass().getMethod("set" + propertyName, propertyClass);
            final Method getValueMethod = dataType.getClass().getMethod("get" + propertyName);

            setValueMethod.invoke(dataType, propertyValue);
            assertEquals(propertyValue, getValueMethod.invoke(dataType));
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Attempt to determine the field name (starting with one or more lower case characters) from the property name
     * (starting with one or more upper case characters).
     *
     * @param propertyName the property name (starting with one or more upper case characters).
     * @return the predicted field name (starting with one or more lower case characters).
     */
    private String getFieldName(final String propertyName) {
        int upperCaseLength = 1;
        while (upperCaseLength < propertyName.length() && Character.isUpperCase(propertyName.charAt(upperCaseLength)))
            upperCaseLength++;

        return propertyName.substring(0, upperCaseLength).toLowerCase() + propertyName.substring(upperCaseLength);
    }

    /**
     * Create an object of a certain data type class (using the default constructor).
     *
     * @param dataTypeClass the data type class to create an instance from.
     * @return the instance of the data type class or null if object construction failed.
     */
    private Object createDataType(final Class dataTypeClass) {
        Object dataType = null;

        try {
            final Method createDataTypeMethod = ObjectFactory.class.getMethod("create" + dataTypeClass.getSimpleName());
            final ObjectFactory objectFactory = new ObjectFactory();
            dataType = createDataTypeMethod.invoke(objectFactory);
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        return dataType;
    }

    /**
     * Test whether a list field of a specific data type class can be set and get.
     *
     * @param dataTypeClass the data type class to create an instance from.
     * @param propertyName  the property name (starting with one or more upper case characters).
     */
    @SuppressWarnings("unchecked")
    private void testListField(final Class dataTypeClass, final String propertyName) {
        try {
            final Object dataType = createDataType(dataTypeClass);
            final Method getListMethod = dataType.getClass().getMethod("get" + propertyName);
            final Object item = "item";

            // Note: even when the list has a type that does not support strings, adding the item works because of type
            // erasure (Java generics only work at compile time; each List<SomeClass> is a non-generic List at run-time).
            // See for example https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure for more
            // information.

            // For example, the ManifestType class has a field called reference which has type List<ReferenceType>. We
            // can add a string to this list at run-time without problems. The @SuppressWarnings("unchecked") annotation
            // at the top of this method suppresses compiler messages for the call to add on the non-generic List.

            ((List) getListMethod.invoke(dataType)).add(item);

            assertEquals(1, ((List) getListMethod.invoke(dataType)).size());
            assertEquals(item, ((List) getListMethod.invoke(dataType)).get(0));
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }
}
