package nl.vumc.odmtoi2b2.generated;

import com.google.common.collect.ImmutableMap;
import com.google.common.reflect.ClassPath;
import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBElement;
import javax.xml.datatype.XMLGregorianCalendar;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;

/**
 * Unit tests for all the ODM reader classes that are automatically generated by the JAXB xjc tool.
 *
 * The generated classes are not tested extensively, since we assume that the ODM schema files are correct and that the
 * xjc tool is able to generate the Java classes in the right way.
 *
 * @author <a href="mailto:f.debruijn@vumc.nl">Freek de Bruijn</a>
 */
public class GeneratedClassesTest {
    /**
     * The packages that contain the generated classes.
     */
    private static final List<String> PACKAGE_NAMES = Arrays.asList("org.cdisk.odm.jaxb", "org.w3.xmldsig.jaxb");

    /**
     * Some special cases in which the general prediction of field names from property names does not work.
     */
    private static final Map<String, String> PROPERTY_TO_FIELD_NAMES = ImmutableMap.of(
            "ODMVersion", "odmVersion",
            "SASDatasetName", "sasDatasetName",
            "SASFieldName", "sasFieldName",
            "SASFormatName", "sasFormatName",
            "SDSVarName", "sdsVarName"
    );

    /**
     * Test whether all fields can be set and get.
     */
    @Test
    public void testFieldSettersAndGetters() {
        try {
            final ClassPath classPath = ClassPath.from(Thread.currentThread().getContextClassLoader());
            for (final String packageName : PACKAGE_NAMES)
                for (final ClassPath.ClassInfo classInfo : classPath.getTopLevelClassesRecursive(packageName))
                    testFieldSettersAndGettersForClass(Class.forName(classInfo.getName()));
        } catch (final ClassNotFoundException | IOException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Test whether all fields can be set and get for objects of a specific class.
     *
     * @param generatedClass the generated class to test.
     */
    private void testFieldSettersAndGettersForClass(final Class generatedClass) {
        for (final Method method : generatedClass.getDeclaredMethods())
            if (method.getName().startsWith("get")) {
                final String propertyName = method.getName().substring(3);
                if (method.getReturnType() != List.class)
                    testSingleField(generatedClass, propertyName);
                else
                    testListField(generatedClass, propertyName);
            }
    }

    /**
     * Test whether a single field of a specific generated class can be set and get.
     *
     * @param generatedClass the generated class to test.
     * @param propertyName   the name of the property (starting with one or more upper case characters).
     */
    private void testSingleField(final Class generatedClass, final String propertyName) {
        try {
            final String fieldName = getFieldName(propertyName);
            final Object generatedClassObject = createGeneratedClassObject(generatedClass);
            final Class propertyClass = generatedClassObject.getClass().getDeclaredField(fieldName).getType();

            final Method setValueMethod = generatedClassObject.getClass().getMethod("set" + propertyName, propertyClass);
            final Method getValueMethod = generatedClassObject.getClass().getMethod("get" + propertyName);
            final Object propertyValue = createPropertyValue(propertyClass);

            setValueMethod.invoke(generatedClassObject, propertyValue);
            assertEquals(propertyValue, getValueMethod.invoke(generatedClassObject));
        } catch (final ReflectiveOperationException e) {
            System.err.println("Exception in testSingleField - generatedClass: " + generatedClass.getName()
                               + "; propertyName: " + propertyName);
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Attempt to determine the field name (starting with one or more lower case characters) from the property name
     * (starting with one or more upper case characters).
     *
     * @param propertyName the property name (starting with one or more upper case characters).
     * @return the predicted field name (starting with one or more lower case characters).
     */
    private String getFieldName(final String propertyName) {
        final String fieldName;

        if (PROPERTY_TO_FIELD_NAMES.containsKey(propertyName))
            fieldName = PROPERTY_TO_FIELD_NAMES.get(propertyName);
        else {
            int upperCaseLength = 1;
            while (upperCaseLength < propertyName.length() && Character.isUpperCase(propertyName.charAt(upperCaseLength)))
                upperCaseLength++;

            fieldName = propertyName.substring(0, upperCaseLength).toLowerCase() + propertyName.substring(upperCaseLength);
        }

        return fieldName;
    }

    /**
     * Create an dummy object of a certain class.
     *
     * @param propertyClass the class to create an instance from.
     * @return the instance of the generated class or null if object construction failed.
     */
    private Object createPropertyValue(final Class propertyClass) {
        final Object propertyValue;

        if (propertyClass == Object.class)
            propertyValue = "object";
        else if (propertyClass == String.class)
            propertyValue = "string";
        else if (propertyClass == byte[].class)
            propertyValue = "byte array".getBytes();
        else if (propertyClass == BigDecimal.class)
            propertyValue = new BigDecimal("123456.7890");
        else if (propertyClass == BigInteger.class)
            propertyValue = new BigInteger("123456");
        else if (propertyClass == XMLGregorianCalendar.class)
            propertyValue = new XMLGregorianCalendarImpl();
        else if (propertyClass.isEnum())
            propertyValue = propertyClass.getEnumConstants()[0];
        else
            propertyValue = createGeneratedClassObject(propertyClass);

        return propertyValue;
    }

    /**
     * Create an object of a certain generated class (using the default constructor).
     *
     * @param generatedClass the generated class to create an instance from.
     * @return the instance of the generated class or null if object construction failed.
     */
    private Object createGeneratedClassObject(final Class generatedClass) {
        Object generatedClassObject = null;

        try {
            final Object objectFactory;
            if (generatedClass.getName().startsWith("org.cdisk.odm.jaxb"))
                objectFactory = org.cdisk.odm.jaxb.ObjectFactory.class.newInstance();
            else if (generatedClass.getName().startsWith("org.w3.xmldsig.jaxb"))
                objectFactory = org.w3.xmldsig.jaxb.ObjectFactory.class.newInstance();
            else
                objectFactory = null;

            if (objectFactory != null) {
                final String creatorMethodName = "create" + generatedClass.getSimpleName();
                final Method creatorMethod = objectFactory.getClass().getMethod(creatorMethodName);
                generatedClassObject = creatorMethod.invoke(objectFactory);
            } else {
                fail("Error creating object factory for generated class " + generatedClass.getName());
            }
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        return generatedClassObject;
    }

    /**
     * Test whether a list field of a specific generated class can be set and get.
     *
     * @param generatedClass the generated class to create an instance from.
     * @param propertyName   the property name (starting with one or more upper case characters).
     */
    @SuppressWarnings("unchecked")
    private void testListField(final Class generatedClass, final String propertyName) {
        try {
            final Object generatedClassObject = createGeneratedClassObject(generatedClass);
            final Method getListMethod = generatedClassObject.getClass().getMethod("get" + propertyName);
            final Object item = "item";

            // Note: even when the list has a type that does not support strings, adding the item works because of type
            // erasure (Java generics only work at compile time; each List<SomeClass> is a non-generic List at run-time).
            // See for example https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure for more
            // information.

            // For example, the ManifestType class has a field called reference which has type List<ReferenceType>. We
            // can add a string to this list at run-time without problems. The @SuppressWarnings("unchecked") annotation
            // at the top of this method suppresses compiler messages for the call to add on the non-generic List.

            ((List) getListMethod.invoke(generatedClassObject)).add(item);

            assertEquals(1, ((List) getListMethod.invoke(generatedClassObject)).size());
            assertEquals(item, ((List) getListMethod.invoke(generatedClassObject)).get(0));
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Test the value, fromValue, and valueOf methods for the enum classes.
     */
    @Test
    public void testEnumClassesMethods() {
        try {
            final ClassPath classPath = ClassPath.from(Thread.currentThread().getContextClassLoader());
            for (final String packageName : PACKAGE_NAMES)
                for (final ClassPath.ClassInfo classInfo : classPath.getTopLevelClassesRecursive(packageName)) {
                    final Class generatedClass = Class.forName(classInfo.getName());
                    if (generatedClass.isEnum())
                        testEnumClassMethods(generatedClass);
                }
        } catch (final ClassNotFoundException | IOException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Check the value, fromValue, and valueOf methods for an enum class.
     *
     * @param generatedClass the generated class to test.
     */
    private void testEnumClassMethods(final Class<?> generatedClass) {
        try {
            final Method valueMethod = generatedClass.getMethod("value");
            final Method fromValueMethod = generatedClass.getMethod("fromValue", String.class);
            final Method valueOfMethod = generatedClass.getMethod("valueOf", String.class);

            for (final Object enumConstant : generatedClass.getEnumConstants()) {
                final String enumValue = valueMethod.invoke(enumConstant).toString();
                final Object enumFromValue = fromValueMethod.invoke(null, enumValue);
                assertEquals(enumConstant, enumFromValue);
                final Object enumValueOf = valueOfMethod.invoke(null, ((Enum) enumConstant).name());
                assertEquals(enumConstant, enumValueOf);
            }

            // Check the fromValue method with an illegal argument.
            try {
                fromValueMethod.invoke(null, "");
                // We expect an IllegalArgumentException, which is translated into an InvocationTargetException.
                fail("Calling fromValue with an empty string should throw a IllegalArgumentException.");
            } catch (final InvocationTargetException e) {
                assertNull(e.getMessage());
            }
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Test the object factory create methods that return a JAXBElement.
     */
    @Test
    public void testCreateMethodsObjectFactories() {
        try {
            for (final String packageName : PACKAGE_NAMES) {
                final Object objectFactory;
                if (packageName.equals("org.cdisk.odm.jaxb"))
                    objectFactory = org.cdisk.odm.jaxb.ObjectFactory.class.newInstance();
                else if (packageName.startsWith("org.w3.xmldsig.jaxb"))
                    objectFactory = org.w3.xmldsig.jaxb.ObjectFactory.class.newInstance();
                else
                    objectFactory = null;

                if (objectFactory != null)
                    for (final Method method : objectFactory.getClass().getDeclaredMethods())
                        if (method.getParameterTypes().length == 1 && method.getReturnType() == JAXBElement.class)
                            testCreateMethodObjectFactory(objectFactory, method);
            }
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Test an object factory create method that returns a JAXBElement.
     *
     * @param objectFactory the object factory to test.
     * @param method        the create method to test.
     * @throws ReflectiveOperationException when a reflection error occurs.
     */
    private void testCreateMethodObjectFactory(final Object objectFactory, final Method method)
            throws ReflectiveOperationException {
        final Class parameterClass = method.getParameterTypes()[0];
        final Object parameterValue = createPropertyValue(parameterClass);
        final Object createdObject = method.invoke(objectFactory, parameterValue);
        final Class<?> createdObjectClass = createdObject.getClass();
        final Object declaredType = createdObjectClass.getDeclaredMethod("getDeclaredType").invoke(createdObject);
        final Object value = createdObjectClass.getDeclaredMethod("getValue").invoke(createdObject);
        assertEquals(parameterClass, declaredType);
        assertEquals(parameterValue, value);
    }
}
