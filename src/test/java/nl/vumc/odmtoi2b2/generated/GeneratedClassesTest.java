package nl.vumc.odmtoi2b2.generated;

import com.google.common.collect.ImmutableMap;
import com.google.common.reflect.ClassPath;
import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

import java.io.IOException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;
import java.util.Map;

import javax.xml.datatype.XMLGregorianCalendar;

import org.cdisk.odm.jaxb.CLDataType;
import org.cdisk.odm.jaxb.CommentType;
import org.cdisk.odm.jaxb.Comparator;
import org.cdisk.odm.jaxb.DataType;
import org.cdisk.odm.jaxb.EditPointType;
import org.cdisk.odm.jaxb.EventType;
import org.cdisk.odm.jaxb.FileType;
import org.cdisk.odm.jaxb.Granularity;
import org.cdisk.odm.jaxb.LocationType;
import org.cdisk.odm.jaxb.MethodType;
import org.cdisk.odm.jaxb.SignMethod;
import org.cdisk.odm.jaxb.SoftOrHard;
import org.cdisk.odm.jaxb.TransactionType;
import org.cdisk.odm.jaxb.UserType;
import org.cdisk.odm.jaxb.YesOnly;
import org.cdisk.odm.jaxb.YesOrNo;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

/**
 * Unit tests for all the ODM reader classes that are automatically generated by the JAXB xjc tool.
 *
 * @author <a href="mailto:f.debruijn@vumc.nl">Freek de Bruijn</a>
 */
public class GeneratedClassesTest {
    /**
     * Special cases in which the general prediction does not work.
     */
    private static final Map<String, String> PROPERTY_TO_FIELD_NAMES = ImmutableMap.of(
            "ODMVersion", "odmVersion",
            "SASDatasetName", "sasDatasetName",
            "SASFieldName", "sasFieldName",
            "SASFormatName", "sasFormatName",
            "SDSVarName", "sdsVarName"
    );

    /**
     * Test whether all fields can be set and get.
     */
    @Test
    public void testFields() {
        try {
            final ClassPath classPath = ClassPath.from(Thread.currentThread().getContextClassLoader());
            for (final ClassPath.ClassInfo classInfo : classPath.getTopLevelClassesRecursive("org.cdisk.odm.jaxb"))
                testFieldsForClass(Class.forName(classInfo.getName()));
            for (final ClassPath.ClassInfo classInfo : classPath.getTopLevelClassesRecursive("org.w3.xmldsig.jaxb"))
                testFieldsForClass(Class.forName(classInfo.getName()));
        } catch (final ClassNotFoundException | IOException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        // todo: check value and fromValue methods for enum classes like SignMethod.class.
    }

    /**
     * Test whether all fields can be set and get for objects of a specific class.
     *
     * @param dataTypeClass the data type class to test.
     */
    private void testFieldsForClass(final Class dataTypeClass) {
        for (final Method method : dataTypeClass.getDeclaredMethods())
            if (method.getName().startsWith("get")) {
                final String propertyName = method.getName().substring(3);
                if (method.getReturnType() != List.class)
                    testSingleField(dataTypeClass, propertyName);
                else
                    testListField(dataTypeClass, propertyName);
            }
    }

    /**
     * Test whether a single field of a specific data type class can be set and get.
     *
     * @param dataTypeClass the data type class to test.
     * @param propertyName  the name of the property (starting with one or more upper case characters).
     */
    private void testSingleField(final Class dataTypeClass, final String propertyName) {
        try {
            final String fieldName = getFieldName(propertyName);
            final Object dataType = createDataType(dataTypeClass);
            final Class propertyClass = dataType.getClass().getDeclaredField(fieldName).getType();

            final Object propertyValue;
            if (propertyClass == Object.class)
                propertyValue = "object";
            else if (propertyClass == String.class)
                propertyValue = "string";
            else if (propertyClass == byte[].class)
                propertyValue = "byte array".getBytes();
            else if (propertyClass == BigDecimal.class)
                propertyValue = new BigDecimal("123456.7890");
            else if (propertyClass == BigInteger.class)
                propertyValue = new BigInteger("123456");
            // todo: can we pick a value for enum classes automatically?
            else if (propertyClass == CLDataType.class)
                propertyValue = CLDataType.TEXT;
            else if (propertyClass == CommentType.class)
                propertyValue = CommentType.SPONSOR;
            else if (propertyClass == Comparator.class)
                propertyValue = Comparator.NOTIN;
            else if (propertyClass == DataType.class)
                propertyValue = DataType.INCOMPLETE_DATE;
            else if (propertyClass == EditPointType.class)
                propertyValue = EditPointType.MONITORING;
            else if (propertyClass == EventType.class)
                propertyValue = EventType.COMMON;
            else if (propertyClass == FileType.class)
                propertyValue = FileType.TRANSACTIONAL;
            else if (propertyClass == Granularity.class)
                propertyValue = Granularity.ALL_CLINICAL_DATA;
            else if (propertyClass == LocationType.class)
                propertyValue = LocationType.LAB;
            else if (propertyClass == MethodType.class)
                propertyValue = MethodType.COMPUTATION;
            else if (propertyClass == SignMethod.class)
                propertyValue = SignMethod.DIGITAL;
            else if (propertyClass == SoftOrHard.class)
                propertyValue = SoftOrHard.SOFT;
            else if (propertyClass == TransactionType.class)
                propertyValue = TransactionType.UPSERT;
            else if (propertyClass == UserType.class)
                propertyValue = UserType.INVESTIGATOR;
            else if (propertyClass == YesOnly.class)
                propertyValue = YesOnly.YES;
            else if (propertyClass == YesOrNo.class)
                propertyValue = YesOrNo.NO;
            else if (propertyClass == XMLGregorianCalendar.class)
                propertyValue = new XMLGregorianCalendarImpl();
            else {
//                System.out.println("Calling createDataType in testSingleField - dataTypeClass: " + dataTypeClass.getName()
//                                   + "; propertyName: " + propertyName);
                propertyValue = createDataType(propertyClass);
            }

            final Method setValueMethod = dataType.getClass().getMethod("set" + propertyName, propertyClass);
            final Method getValueMethod = dataType.getClass().getMethod("get" + propertyName);

            setValueMethod.invoke(dataType, propertyValue);
            assertEquals(propertyValue, getValueMethod.invoke(dataType));
        } catch (final ReflectiveOperationException e) {
            System.err.println("Exception in testSingleField - dataTypeClass: " + dataTypeClass.getName()
                               + "; propertyName: " + propertyName);
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

    /**
     * Attempt to determine the field name (starting with one or more lower case characters) from the property name
     * (starting with one or more upper case characters).
     *
     * @param propertyName the property name (starting with one or more upper case characters).
     * @return the predicted field name (starting with one or more lower case characters).
     */
    private String getFieldName(final String propertyName) {
        final String fieldName;

        if (PROPERTY_TO_FIELD_NAMES.containsKey(propertyName))
            fieldName = PROPERTY_TO_FIELD_NAMES.get(propertyName);
        else {
            int upperCaseLength = 1;
            while (upperCaseLength < propertyName.length() && Character.isUpperCase(propertyName.charAt(upperCaseLength)))
                upperCaseLength++;

            fieldName = propertyName.substring(0, upperCaseLength).toLowerCase() + propertyName.substring(upperCaseLength);
        }

        return fieldName;
    }

    /**
     * Create an object of a certain data type class (using the default constructor).
     *
     * @param dataTypeClass the data type class to create an instance from.
     * @return the instance of the data type class or null if object construction failed.
     */
    private Object createDataType(final Class dataTypeClass) {
        Object dataType = null;

        try {
            final Object objectFactory;
            if (dataTypeClass.getName().startsWith("org.cdisk.odm.jaxb"))
                objectFactory = org.cdisk.odm.jaxb.ObjectFactory.class.newInstance();
            else if (dataTypeClass.getName().startsWith("org.w3.xmldsig.jaxb"))
                objectFactory = org.w3.xmldsig.jaxb.ObjectFactory.class.newInstance();
            else
                objectFactory = null;

            if (objectFactory != null) {
                final String creatorMethodName = "create" + dataTypeClass.getSimpleName();
                final Method createDataTypeMethod = objectFactory.getClass().getMethod(creatorMethodName);
                dataType = createDataTypeMethod.invoke(objectFactory);
            } else {
                fail("Error creating object factory for data type class " + dataTypeClass.getName());
            }
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        return dataType;
    }

    /**
     * Test whether a list field of a specific data type class can be set and get.
     *
     * @param dataTypeClass the data type class to create an instance from.
     * @param propertyName  the property name (starting with one or more upper case characters).
     */
    @SuppressWarnings("unchecked")
    private void testListField(final Class dataTypeClass, final String propertyName) {
        try {
            final Object dataType = createDataType(dataTypeClass);
            final Method getListMethod = dataType.getClass().getMethod("get" + propertyName);
            final Object item = "item";

            // Note: even when the list has a type that does not support strings, adding the item works because of type
            // erasure (Java generics only work at compile time; each List<SomeClass> is a non-generic List at run-time).
            // See for example https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure for more
            // information.

            // For example, the ManifestType class has a field called reference which has type List<ReferenceType>. We
            // can add a string to this list at run-time without problems. The @SuppressWarnings("unchecked") annotation
            // at the top of this method suppresses compiler messages for the call to add on the non-generic List.

            ((List) getListMethod.invoke(dataType)).add(item);

            assertEquals(1, ((List) getListMethod.invoke(dataType)).size());
            assertEquals(item, ((List) getListMethod.invoke(dataType)).get(0));
        } catch (final ReflectiveOperationException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }
}
